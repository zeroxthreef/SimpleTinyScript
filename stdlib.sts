# this file is released into the public domain

# This is the STS standard library. It is written in STS
# instead of C to keep the source of the interpreter
# smaller than it would be if this were entirely C.

# The following implements hashmaps, string management,
# file parsing, and other uncategorized utility functions.


# stdlib globals ========================


global stdlib-current-error ""

# sts type globals (are functions to make constant)
function STS_EXTERNAL {copy 0}
function STS_NIL {copy 1}
function STS_NUMBER {copy 2}
function STS_STRING {copy 3}
function STS_ARRAY {copy 4}
function STS_FUNCTION {copy 5}


# hashmap implementation ================

# hashmap structure:
#   [array
#       [array *hash* *key string* *value*]
#       [array *hash* *key string* *value*]
#       ...
#   ]

function hashmap {
    local ret $nil
    local row $nil
    local break 0
    local i 0

    # TODO: possibly insert at 0 so its 3 less function calls

    if(! (sizeof $...)) {
        set $ret [array]
    }
    elseif(% (sizeof $...) 2) {
        stdlib-set-error hashmap "arguments provided were not an even number"
    }
    else {
        set $ret [array]

        loop(&& [< $i (sizeof $...)] [! $break]) {
            if(!= (typeof [get $... $i]) (STS_STRING)) {
                stdlib-set-error hashmap "keys need to be strings"
                set $ret $nil
                ++ $break
            }
            else {
                set $row [array (string-hash [get $... $i]) (get $... $i) (get $... (+ $i 1))]

                # theres a quirk with the language that results in just inserting the literal
                # row value itself. This makes all rows the extact same and just duplicates forever.
                # The solution is to just create space in the array and set the new space to
                # the new row. The set action shallow copies the value so the array itself is
                # duplicated but all row values are just references to the originals passed.
                # The most important part is initializing the space with anything that is generated
                # rather than part of the ast (so literals will NOT work). $nil is special because
                # the eval function creates a new nil value every time it is used. This makes it
                # perfect for this.

                insert $ret (sizeof $ret) $nil
                set (get $ret [- (sizeof $ret) 1]) $row


                # unfortunately, this will not work

                # insert $ret (sizeof $ret) $row
            }

            += $i 2
        }
    }

    pass $ret
}

function hashmap-get map key {
    local ret $nil
    local hash $nil
    local break 0
    local i 0

    if(&& [!= $map (STS_ARRAY)] [!= $key (STS_STRING)]) {
        stdlib-set-error hashmap "the map arg must be an array and the key must be a string"
    }
    else {
        set $hash (string-hash $key)

        loop(&& [< $i (sizeof $map)] [! $break]) {
            if(== $hash [get [get $map $i] 0]) {
                set $ret [get [get $map $i] 2]
                ++ $break
            }

            ++ $i
        }
    }

    if(== $ret $nil) {
        stdlib-set-error hashmap "could not find value for key provided"
    }

    pass $ret
}

function hashmap-exists map key {
    local ret 1


    if(&& [== [hashmap-get $map $key] $nil] [== (stdlib-get-error) "hashmap: could not find value for key provided"]) {
        set $ret 0
    }

    pass $ret
}

# hashmap-get returns 0 if the key already existed and 1 if a new one had to be created
function hashmap-set map key value {
    local ret $nil
    local row $nil
    local hash $nil
    local break 0
    local i 0

    if(&& [!= $map (STS_ARRAY)] [!= $key (STS_STRING)]) {
        stdlib-set-error hashmap "the map arg must be an array and the key must be a string"
    }
    else {
        set $hash (string-hash $key)

        loop(&& [< $i (sizeof $map)] [! $break]) {
            if(== $hash [get [get $map $i] 0]) {
                set [get [get $map $i] 2] $value
                set $ret 0
                ++ $break
            }

            ++ $i
        }
    }

    # add new key instead
    if(== $ret $nil) {
        set $row [array (string-hash $key) $key $value]

        insert $map (sizeof $map) $nil
        set (get $map [- (sizeof $map) 1]) $row

        set $ret 1
    }

    pass $ret
}

function hashmap-remove map key {
    local ret 0
    local hash $nil
    local break 0
    local i 0

    if(&& [!= $map (STS_ARRAY)] [!= $key (STS_STRING)]) {
        stdlib-set-error hashmap "the map arg must be an array and the key must be a string"
    }
    else {
        set $hash (string-hash $key)

        loop(&& [< $i (sizeof $map)] [! $break]) {
            if(== $hash [get [get $map $i] 0]) {
                remove $map $i
                set $ret 1
                ++ $break
            }

            ++ $i
        }
    }

    pass $ret
}

# because keys are passed by reference and stored in the row rather than
# copied into the row, the key could change at some point and thats mostly
# ok, but the string hash needs to be updated as well. Call this if theres
# a possibility that the keys updated in the hashmap
function hashmap-update map {
    local ret $nil
    local i 0


    if(!= $map (STS_ARRAY)) {
        stdlib-set-error hashmap "the map arg must be an array"
    }
    else {
        loop(< $i (sizeof $map)) {
            set [get [get $map $i] 0]   (string-hash [get [get $map $i] 1])

            ++ $i
        }
    }

    pass $ret
}


# string management =====================


function string-tokenize string token {

}

function string-range string start end {

}

function string-search string needle {

}

function string-rsearch string needle {
    
}

function string-insert string position instring {

}

function string-remove string position {

}

function string-replace string replacement {

}


# uncategorized =========================

function stdlib-get-error {
    local ret "no error"

    if(== (typeof $stdlib-current-error) (STS_STRING)) {
        set $ret (copy $stdlib-current-error)
    }

    # clear the error
    set $stdlib-current-error $nil
    
    pass $ret
}

function stdlib-set-error component_str error_str {
    set $stdlib-current-error (string $component_str ": " $error_str)
}

# returns a string of a recursively indexed value. Useful for debugging data structures
function string-value-print value {
    local ret $nil
    local i 0


    if(== (typeof $value) (STS_NIL)) {
        if(!= (typeof $ret) (STS_STRING)) {set $ret (string $value)}
    }
    elseif(== (typeof $value) (STS_FUNCTION)) {
        if(!= (typeof $ret) (STS_STRING)) {set $ret (string $value)}
    }
    elseif(== (typeof $value) (STS_EXTERNAL)) {
        if(!= (typeof $ret) (STS_STRING)) {set $ret (string $value)}
    }
    elseif(== (typeof $value) (STS_ARRAY)) {
        if(!= (typeof $ret) (STS_STRING)) {set $ret (string "[array (" (sizeof $value) " elements):")}
        
        loop(< $i (sizeof $value)) {
            set $ret (string $ret ", " [string-value-print (get $value $i)])
            ++ $i
        }

        set $ret (string $ret "]")
    }
    elseif(== (typeof $value) (STS_NUMBER)) {
        if(!= (typeof $ret) (STS_STRING)) {set $ret (string $value)}
    }
    elseif(== (typeof $value) (STS_STRING)) {
        if(!= (typeof $ret) (STS_STRING)) {set $ret (string "\"" $value "\"")}
    }

    pass $ret
}

function expr { # turn arguments into an expression and evaluate it
    local $ret 0



    pass $ret
}

function enum {
    # create a bunch of locals
}

function += lvalue rvalue {set $lvalue (+ $lvalue $rvalue); pass $lvalue} # because all arguments are passed by value, this passes the value and performs the operation on it
function -= lvalue rvalue {set $lvalue (- $lvalue $rvalue); pass $lvalue}
function *= lvalue rvalue {set $lvalue (* $lvalue $rvalue); pass $lvalue}
function /= lvalue rvalue {set $lvalue (/ $lvalue $rvalue); pass $lvalue}
function %= lvalue rvalue {set $lvalue (% $lvalue $rvalue); pass $lvalue}
function **= lvalue rvalue {set $lvalue (** $lvalue $rvalue); pass $lvalue}